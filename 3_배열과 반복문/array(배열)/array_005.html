<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 배열 사용시 몰라서는 안되는 유용한 method(함수)

        // 배열은 여러가지 타입을 넣을 수 있다.
        // let array=["하늘", 100, true] : "하늘" (string), 100 (number), true(boolean)
        // 일반적으로 같은 타입을 묶는다.

        // 배열과 객체는 동적 할당을 받는다.
        // 동적 할당 : 메모리 공간이 늘어나거나 줄어들 수 있다.

        let arr = []
        arr.push('한국') // 한국
        arr.push('미국') // 한국, 미국
        arr.push('중국') // 한국, 미국, 중국 ( push : 하나씩 뒤에 추가가 된다.)

        console.log(arr)

        let animals = ['사자', '호랑이', '늑대', '코끼리', '개', '고양이', '양', '하마'] // 0,1,2,3,4,5 ..... 순으로 번호가 매겨진다.

        console.log(animals[0]) // 사자
        console.log(animals[3]) // 코끼리
        console.log(animals.length) // 8개 : 배열의 갯수가 몇개가 있나요?

        // 🚀자주 쓰인다🚀 배열중 가장 끝에 있는 아이템
        console.log(animals[animals.length - 1]) // 하마

        // index 범위를 벗어나는 경우
        console.log(animals[22]) // undefined(false) : 찾을 수 없다.

        // 반복 (1.for,   2.for..in,   3.for..of,   🚀3.배열명.forEach())

        // 1. for
        console.clear() // 모든 console이 지워진다.

        console.log("--------------for")
        // for(초기값 1️⃣; 조건문 2️⃣; 증가감식을 거쳐서 나간다.4️⃣){
        //     조건문이 참일때 실행문3️⃣
        // } : 초기값(변수) => 조건문 => 조건문이 참일때 실행문 => 증가감식을 거쳐서 나간다.

        for (let i = 0; i < animals.length; i++) {
            document.write(animals[i])
        }
        // : i는 0이다. => 동물의 총 갯수가 i보다 작다면 => 페이지에 적어라. => i의 숫자가 1씩 점점 커지며 조건문이 성립되지 않을때까지 다시 반복된다.

        document.write("<br>")
        document.write("<br>")

        // 별 ***** 부터 *까지 찍히게 하기 1
        let stars = ['*****', '****', '***', '**', '*']
        for (let i = 0; i < stars.length; i++) {
            document.write(stars[i])
            document.write("<br>")
        }
        // : i는 0이다. => stars 의 총 갯수가 i보다 작다면 => 페이지에 적어라. 줄 넘기기도 해라 => i의 숫자가 1씩 점점 커지며 조건문이 성립되지 않을때까지 다시 반복된다.


        // 별 ***** 부터 *까지 찍히게 하기 2
        for (let i = 0; i < 5; i++) {
            for (let j = 5; j > i; j--) {
                document.write("*")
            }
            document.write("<br>")
        }
        // : i는 0이다. => i가 5보다 작다면 => 페이지에 "*"을 적어라. => 무한 반복 => i가 5보다 작아지면 아래로 넘어간다.
        // : j 는 5다. => j(5)가 i보다 크다면 => 줄넘김을 하고, j는 1씩 작아져라

        // for ..in : 인덱스 번호를 출력한다.
        console.clear()
        console.log("-------------for..in")

        for (let i in animals) {
            console.log(i) // index number --> 0,1,2,3,4....
        }

        // for ..of : value 값을 출력한다.
        console.clear()
        console.log("-------------for..of")

        for (let i of animals) {
            console.log(i) // value --> 사자, 호랑이, 늑대, 코끼리 ... 
        }

        // forEach : 아이템 하나하나에게 일을 시킨다.
        console.clear()
        console.log("-------------forEach")

        animals.forEach(function (item, idx, oriarr) {
            console.log(item, idx, oriarr) // 모든 아이템이 나타나며 각 item, idx(index number), oriarr(원본 배열)이 출력된다.
        })

        // 화살표 함수로 변경
        animals.forEach((item, idx, oriarr) => console.log(item, idx, oriarr))


        //Spread Operator(펼침 연산자) : 배열 내의 요소들을 하나씩 나열해 준다. (이 자체로 배열이 아니다.)
        console.clear()
        console.log("-------------Spread Operator")
        console.log(animals) // : 배열 자체를 보여줘라.
        console.log(...animals) // : 배열 안의 아이템을을 전부 가져와라.
        console.log([...animals]) // : animal 과 똑같이 보인다. (배열)



        // split()메서드 🚀🚀 react 에서 자주 사용, 절대 원본을 손상해선 안된다.
        // 기능 --> 문자열을 배열로 리턴 --> 즉, 문자열에서 특정한 구분자를 기준으로 잘라내서 새로운 배열로 리턴한다.
        // 사용 --> 문자열.split(separator(구분자),limit(한정값))

        let someSt = "고기도 먹어 본 사람이 더 잘 먹는다"
        let splitted = someSt.split(" ", 3) // : (3) 고기도, 먹어, 본
        console.log(splitted)

        let someSt2 = "고기도,먹어,본,사람이,더,잘,먹는다"
        let splitted2 = someSt2.split(",", 3) // : , 를 기준으로 잘린다. (3) 고기도, 먹어, 본
        console.log(splitted2)

        let splitted3 = someSt2.split(",") // 분할 갯수 옵션이 지정되지 않는다면 문자열 전부를 잘라서 배열로 리턴한다. 
        console.log(splitted3)
        console.log(splitted3[splitted3.length - 1])



        let array = ['딸기', '포도', '복숭아', '바나나', '수박']
        // 🚀🚀 slice() 메서드 : 원본 배열은 손상되지 않는다. 🚀🚀

        // slice(start[,end]) : end 는 생략이 가능하다. 🚀 문법적으로 [,end]라 적혀있으면 해당 부분은 생략이 가능하다는 뜻이다.
        // end => 지정한 end 전까지 잘라낸다.

        // array.slice(1); // index 1 포함해서 그 뒤로는 모두 잘라낸다.
        // array.slice(1,4); // index 1 부터 index 4 이전 (3번까지 잘라낸다.)
        let slice1 = array.slice(1); // index 1 포함해서 그 뒤로는 모두 잘라낸다.
        console.log(slice1) // : 4) ['포도', '복숭아', '바나나', '수박'] , 1번째인 딸기가 제외됐다.
        console.log(array)


        
        //splice() 메서드 
        //배열의 기존 요소를 삭제하거나 교체하고자 할때
        //원본이 수정됨
        let array2 = ['딸기', '포도', '복숭아', '바나나', '수박']

        let splice1=array2.splice(3)//index 3부터 뒤로 잘라옴
        console.log(splice1)//['바나나','수박']
        console.log(array2)//['딸기','포도','복숭아']


           let splice2=array2.splice(1,2)//index 1번 부터 2개를 잘라옴
           console.log(splice2)//['포도','복숭아']

          let splice3=array2.splice(1,2,'강아지','고양이','쥐')//index 1번 부터 2개를 잘려지고 그 자리에 '강아지','고양이','쥐' 가 들어감
          console.log(splice3)//['포도','복숭아']
          console.log(array2)//['딸기', '강아지', '고양이', '쥐', '바나나', '수박']

        let splice4 = array2.splice(-2);  //뒤에서 2개를 잘라옴
        console.log(splice4)

        let splice5 = array2.splice(1, 0, "돼지") //index 1번에 돼지 가 들어감
        console.log(array2)

        //배열 붙이기 concat()
        let myArr1 = [1, 2, 3, 4];
        let myArr2 = [5, 6, 7, 8];

        let myArr3 = myArr1.concat(myArr2)
        console.log(myArr3)
        console.log(myArr2)


        let str1 = "안녕!";
        let str2 = "자바스크립트";

        console.log(str1.concat(" ", str2)) //안녕! 자바스크립트
        console.log(str1.concat(", ", str2)) //안녕!, 자바스크립트
        console.log(str2.concat(", ", str1)) //자바스크립트, 안녕! 

        let someArr = ["안녕!", " ", "난", " ", "뽀로로라고해~", "!!"]

        console.log("".concat(...someArr))

        let 위인 = ['이순신', '세종대왕', '강감찬', '김유신', '홍길동'];


        console.log(위인.indexOf('강감찬')) //2
        console.log(위인.indexOf('세종대왕')) //1
        console.log(위인.indexOf('임꺽정')) // -1 ==> 없는 값을 indexof()메서드로 찾으면 -1이 리턴

        let abcArr1="ABCD EFGHIJKLMN"
        console.log(abcArr1.indexOf('H')); // 8 : 띄워쓰기도 포함하여 8번이 찍힌다.
        console.log(abcArr1.lastIndexOf('H')); // 8 : 뒤에서부터 H의 순서를 세면 8이 나온다.
        console.log(abcArr1.indexOf('h')); // -1 : 대소문자 구분은 하지 못한다.

        // indexOf : 찾을 특정 값, 시작 할 위치
        let abcArr2=['k','o','r','e','a','u','s','a'];
        console.log(abcArr2.indexOf('a')) // 4
        console.log(abcArr2.indexOf('a', 6)) // 7
        
        let abcArr3="Hello, World~!!";
        console.log(abcArr3.indexOf('o')) // 4
        console.log(abcArr3.indexOf('o',5)) // 8
        console.log(abcArr3.indexOf('o',9)) // -1 : 9번부터 시작하여 뒤엔 o가 없기 때문에 -1값이 뜬다.

        // 배열에 특정 요소가 포함되어 있는지 없는지 알기 --> includes()메서드

        let 위인2 = ['이순신', '세종대왕', '강감찬', '김유신', '홍길동'];
        console.log(위인2.includes('강감찬')) // true
        console.log(위인2.includes('아저씨')) // false

        // 배열에 요소들을 하나로 묶어주기(문자열 타입으로 묶음) --> join();
        console.log(위인2.join()) // 이순신,세종대왕,강감찬,김유신,홍길동 : 아무것도 넣지 않으면 기본값 ,
        console.log(위인2.join('-')) // 이순신-세종대왕-강감찬-김유신-홍길동 : - 를 넣어서 사이에 - 가 붙는다.
        console.log(위인2.join(' ')) // 이순신 세종대왕 강감찬 김유신 홍길동 : 띄어쓰기만을 넣으면 사이에 띄어쓰기가 붙는다.
        console.log(위인2.join(', ')) // 이순신, 세종대왕, 강감찬, 김유신, 홍길동 : 넣고싶은대로 들어간다.

        // 배열내에 요소들을 거꾸로 출력하기 --> reverse() : 원본을 훼손하여 react에 사용하기 힘듦.
        console.log(위인2.reverse()) // 5) ['홍길동', '김유신', '강감찬', '세종대왕', '이순신'] : 거꾸로 배열하여 출력된다.
        console.log(위인2) // reverse 특성은 원본을 훼손한다. 👆 위 명령어로 인해 거꾸로 배열이 됐다.

        // 조건에 맞는 첫번째 요소 찾기 --> find() 🚀 react에 사용

        let 위인3 = ['이순신', '세종대왕', '강감찬', '김유신', '홍길동'];
        let found = 위인3.find((item)=>{
            return item == "세종대왕"
        })
        console.log(found)


        let nums=[56,34,89,95,100,90]

        // let found2 = nums.find(item=>item>=80)
        // let found2 = nums.find((item)=>item>=80)
        let found2 = nums.find((item)=>{
            return item>=80}
        )
        console.log(found2) //89 : 하나만 찾고 끝낸다.

        // filter() 메서드 --> 조건에 맞는 값을 모두 다 찾아준다.
        let nums2=[56,34,89,95,100,90]
        
        let filRe=nums2.filter((item)=>{
            return item>=80}
        )
        console.log(filRe) // (4) [89, 95, 100, 90] : 해당되는 모든 값을 배열하여 출력

        // 
        let cars=[
            {name:"테슬라",price:25000},
            {name:"벤츠",price:35000},
            {name:"테슬라",price:55000},
            {name:"벤츠",price:66000},
            {name:"아우디",price:45000},
        ]

        console.log(cars[1].name) // 벤츠


    </script>
</body>

</html>